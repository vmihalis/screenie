---
phase: 03-browser-engine
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/engine/__tests__/browser.test.ts
  - src/engine/__tests__/capturer.test.ts
autonomous: true

must_haves:
  truths:
    - "BrowserManager tests verify launch/close lifecycle"
    - "BrowserManager tests verify context creation for devices"
    - "captureScreenshot tests verify full-page capture works"
    - "captureScreenshot tests verify timeout handling"
    - "All tests pass with npm test"
  artifacts:
    - path: "src/engine/__tests__/browser.test.ts"
      provides: "BrowserManager unit tests"
      contains: "describe"
      min_lines: 40
    - path: "src/engine/__tests__/capturer.test.ts"
      provides: "captureScreenshot unit tests"
      contains: "describe"
      min_lines: 50
  key_links:
    - from: "src/engine/__tests__/browser.test.ts"
      to: "BrowserManager"
      via: "import and instantiation"
      pattern: "new BrowserManager"
    - from: "src/engine/__tests__/capturer.test.ts"
      to: "captureScreenshot"
      via: "import and invocation"
      pattern: "captureScreenshot\\("
---

<objective>
Add comprehensive unit tests for BrowserManager and captureScreenshot.

Purpose: Verify the browser engine works correctly - lifecycle management, device emulation, full-page capture, and timeout handling.

Output: Test files that pass with `npm test` and cover key behaviors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-browser-engine/03-01-SUMMARY.md
@.planning/phases/03-browser-engine/03-02-SUMMARY.md

@src/engine/browser.ts
@src/engine/capturer.ts
@src/engine/types.ts
@src/devices/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BrowserManager tests</name>
  <files>src/engine/__tests__/browser.test.ts</files>
  <action>
Create src/engine/__tests__/browser.test.ts with tests for BrowserManager:

```typescript
import { describe, it, expect, afterEach } from 'vitest';
import { BrowserManager } from '../browser.js';
import type { Device } from '../../devices/types.js';

// Test device fixture
const testDevice: Device = {
  name: 'Test Phone',
  width: 390,
  height: 844,
  deviceScaleFactor: 3,
  category: 'phones',
};

const testTablet: Device = {
  name: 'Test Tablet',
  width: 820,
  height: 1180,
  deviceScaleFactor: 2,
  category: 'tablets',
};

const testDesktop: Device = {
  name: 'Test Desktop',
  width: 1920,
  height: 1080,
  deviceScaleFactor: 1,
  category: 'pc-laptops',
};

describe('BrowserManager', () => {
  let manager: BrowserManager;

  afterEach(async () => {
    // Clean up after each test
    if (manager) {
      await manager.close();
    }
  });

  describe('launch()', () => {
    it('should launch browser successfully', async () => {
      manager = new BrowserManager();
      const browser = await manager.launch();

      expect(browser).toBeDefined();
      expect(manager.isLaunched()).toBe(true);
    });

    it('should reuse existing browser on subsequent calls', async () => {
      manager = new BrowserManager();
      const browser1 = await manager.launch();
      const browser2 = await manager.launch();

      expect(browser1).toBe(browser2);
    });

    it('should launch in headless mode by default', async () => {
      manager = new BrowserManager();
      const browser = await manager.launch();

      // Browser launched successfully means headless worked
      expect(browser).toBeDefined();
    });
  });

  describe('createContext()', () => {
    it('should create context for phone device', async () => {
      manager = new BrowserManager();
      const context = await manager.createContext(testDevice);

      expect(context).toBeDefined();

      // Clean up
      await manager.closeContext(context);
    });

    it('should create context for tablet device', async () => {
      manager = new BrowserManager();
      const context = await manager.createContext(testTablet);

      expect(context).toBeDefined();

      await manager.closeContext(context);
    });

    it('should create context for desktop device', async () => {
      manager = new BrowserManager();
      const context = await manager.createContext(testDesktop);

      expect(context).toBeDefined();

      await manager.closeContext(context);
    });

    it('should auto-launch browser if not launched', async () => {
      manager = new BrowserManager();
      expect(manager.isLaunched()).toBe(false);

      await manager.createContext(testDevice);

      expect(manager.isLaunched()).toBe(true);
    });

    it('should create multiple contexts simultaneously', async () => {
      manager = new BrowserManager();

      const [ctx1, ctx2, ctx3] = await Promise.all([
        manager.createContext(testDevice),
        manager.createContext(testTablet),
        manager.createContext(testDesktop),
      ]);

      expect(ctx1).toBeDefined();
      expect(ctx2).toBeDefined();
      expect(ctx3).toBeDefined();

      // All are different contexts
      expect(ctx1).not.toBe(ctx2);
      expect(ctx2).not.toBe(ctx3);
    });
  });

  describe('close()', () => {
    it('should close browser and all contexts', async () => {
      manager = new BrowserManager();
      await manager.createContext(testDevice);
      await manager.createContext(testTablet);

      expect(manager.isLaunched()).toBe(true);

      await manager.close();

      expect(manager.isLaunched()).toBe(false);
    });

    it('should be safe to call multiple times', async () => {
      manager = new BrowserManager();
      await manager.launch();

      await manager.close();
      await manager.close(); // Should not throw

      expect(manager.isLaunched()).toBe(false);
    });

    it('should allow relaunching after close', async () => {
      manager = new BrowserManager();
      await manager.launch();
      await manager.close();

      const browser = await manager.launch();
      expect(browser).toBeDefined();
      expect(manager.isLaunched()).toBe(true);
    });
  });

  describe('closeContext()', () => {
    it('should close specific context', async () => {
      manager = new BrowserManager();
      const context = await manager.createContext(testDevice);

      await manager.closeContext(context);

      // Context should be closed - trying to use it should fail
      await expect(context.newPage()).rejects.toThrow();
    });

    it('should be safe to call with already-closed context', async () => {
      manager = new BrowserManager();
      const context = await manager.createContext(testDevice);

      await manager.closeContext(context);
      await manager.closeContext(context); // Should not throw
    });
  });

  describe('isLaunched()', () => {
    it('should return false before launch', () => {
      manager = new BrowserManager();
      expect(manager.isLaunched()).toBe(false);
    });

    it('should return true after launch', async () => {
      manager = new BrowserManager();
      await manager.launch();
      expect(manager.isLaunched()).toBe(true);
    });

    it('should return false after close', async () => {
      manager = new BrowserManager();
      await manager.launch();
      await manager.close();
      expect(manager.isLaunched()).toBe(false);
    });
  });
});
```

Key test behaviors:
- Lifecycle: launch, close, relaunch
- Context creation for all device categories
- Multiple simultaneous contexts
- Idempotent close operations
- State tracking with isLaunched()
  </action>
  <verify>
Run `npm test -- src/engine/__tests__/browser.test.ts` - all tests should pass.
  </verify>
  <done>
browser.test.ts contains comprehensive tests for BrowserManager covering launch, createContext, close, closeContext, and isLaunched.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create captureScreenshot tests</name>
  <files>src/engine/__tests__/capturer.test.ts</files>
  <action>
Create src/engine/__tests__/capturer.test.ts with tests for captureScreenshot:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { BrowserManager } from '../browser.js';
import { captureScreenshot } from '../capturer.js';
import { DEFAULT_TIMEOUT } from '../types.js';
import type { Device } from '../../devices/types.js';
import type { CaptureOptions } from '../types.js';

// Test device fixture
const testPhone: Device = {
  name: 'Test iPhone',
  width: 390,
  height: 844,
  deviceScaleFactor: 3,
  category: 'phones',
};

const testDesktop: Device = {
  name: 'Test Desktop',
  width: 1920,
  height: 1080,
  deviceScaleFactor: 1,
  category: 'pc-laptops',
};

describe('captureScreenshot', () => {
  let manager: BrowserManager;

  beforeAll(async () => {
    manager = new BrowserManager();
    await manager.launch();
  });

  afterAll(async () => {
    await manager.close();
  });

  describe('successful captures', () => {
    it('should capture screenshot of simple page', async () => {
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(true);
      expect(result.deviceName).toBe('Test iPhone');
      expect(result.buffer).toBeDefined();
      expect(result.buffer).toBeInstanceOf(Buffer);
      expect(result.buffer!.length).toBeGreaterThan(0);
    });

    it('should capture screenshot with desktop device', async () => {
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testDesktop,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(true);
      expect(result.deviceName).toBe('Test Desktop');
      expect(result.buffer).toBeDefined();
    });

    it('should return PNG format buffer', async () => {
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(true);
      // PNG magic bytes: 0x89 0x50 0x4E 0x47
      const pngMagic = Buffer.from([0x89, 0x50, 0x4e, 0x47]);
      expect(result.buffer!.subarray(0, 4).equals(pngMagic)).toBe(true);
    });

    it('should capture full-page content', async () => {
      // Use a page that's likely to have scrollable content
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(true);
      // Full-page capture means buffer should exist
      expect(result.buffer).toBeDefined();
    });
  });

  describe('error handling', () => {
    it('should return error for invalid URL', async () => {
      const options: CaptureOptions = {
        url: 'https://this-domain-definitely-does-not-exist-12345.com',
        device: testPhone,
        timeout: 5000, // Short timeout for faster test
        waitBuffer: 500,
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(false);
      expect(result.deviceName).toBe('Test iPhone');
      expect(result.error).toBeDefined();
      expect(result.buffer).toBeUndefined();
    });

    it('should return error for malformed URL', async () => {
      const options: CaptureOptions = {
        url: 'not-a-valid-url',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    it('should timeout on slow pages', async () => {
      // Use a very short timeout to trigger timeout
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: 1, // 1ms - will definitely timeout
        waitBuffer: 500,
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
      // Error should mention timeout
      expect(result.error?.toLowerCase()).toContain('timeout');
    });
  });

  describe('context cleanup', () => {
    it('should work with multiple sequential captures', async () => {
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
      };

      // Multiple captures should work (contexts cleaned up properly)
      const result1 = await captureScreenshot(manager, options);
      const result2 = await captureScreenshot(manager, options);
      const result3 = await captureScreenshot(manager, options);

      expect(result1.success).toBe(true);
      expect(result2.success).toBe(true);
      expect(result3.success).toBe(true);
    });

    it('should clean up context even on error', async () => {
      const options: CaptureOptions = {
        url: 'https://this-domain-definitely-does-not-exist-12345.com',
        device: testPhone,
        timeout: 5000,
        waitBuffer: 500,
      };

      // This should fail but clean up context
      await captureScreenshot(manager, options);

      // Subsequent capture should still work
      const validOptions: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
      };

      const result = await captureScreenshot(manager, validOptions);
      expect(result.success).toBe(true);
    });
  });

  describe('device emulation', () => {
    it('should capture with different viewport sizes', async () => {
      const phoneOptions: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
      };

      const desktopOptions: CaptureOptions = {
        url: 'https://example.com',
        device: testDesktop,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
      };

      const phoneResult = await captureScreenshot(manager, phoneOptions);
      const desktopResult = await captureScreenshot(manager, desktopOptions);

      expect(phoneResult.success).toBe(true);
      expect(desktopResult.success).toBe(true);

      // Both should have buffers (different sizes due to viewport)
      expect(phoneResult.buffer).toBeDefined();
      expect(desktopResult.buffer).toBeDefined();
    });
  });
});
```

Key test behaviors:
- Successful capture returns buffer
- PNG format verification
- Error handling for invalid URLs
- Timeout handling
- Context cleanup (sequential captures work)
- Device emulation (different viewports)
  </action>
  <verify>
Run `npm test -- src/engine/__tests__/capturer.test.ts` - all tests should pass.
Run `npm test` - all project tests should pass.
  </verify>
  <done>
capturer.test.ts contains comprehensive tests for captureScreenshot covering successful captures, error handling, timeout handling, context cleanup, and device emulation.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. All tests pass: `npm test` succeeds
2. Browser tests: `npm test -- src/engine/__tests__/browser.test.ts` passes
3. Capturer tests: `npm test -- src/engine/__tests__/capturer.test.ts` passes
4. Test files exist and have content:
   - `src/engine/__tests__/browser.test.ts`
   - `src/engine/__tests__/capturer.test.ts`
</verification>

<success_criteria>
- browser.test.ts covers BrowserManager lifecycle and context management
- capturer.test.ts covers screenshot capture, errors, timeouts, and cleanup
- All tests pass with `npm test`
- Tests use real browser (integration-style) to verify actual behavior
- Tests clean up resources properly (no orphan browsers)
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-engine/03-03-SUMMARY.md`
</output>
