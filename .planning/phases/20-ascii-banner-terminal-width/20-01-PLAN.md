---
phase: 20-ascii-banner-terminal-width
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/banner.ts
  - src/cli/__tests__/banner.test.ts
autonomous: true

must_haves:
  truths:
    - "Banner detects terminal width at runtime"
    - "Falls back to smaller font when terminal is narrow (60-79 columns)"
    - "Falls back to Mini font when terminal is very narrow (45-59 columns)"
    - "Falls back to plain text when terminal is too narrow (<45 columns)"
    - "Non-TTY contexts (pipes, CI) get plain text output"
    - "All existing tests continue to pass"
  artifacts:
    - path: "src/cli/banner.ts"
      provides: "Width-aware banner generation"
      exports: ["generateBanner"]
      contains: "process.stdout.columns"
    - path: "src/cli/__tests__/banner.test.ts"
      provides: "Tests for width-based font selection"
      contains: "narrow terminal"
  key_links:
    - from: "src/cli/banner.ts"
      to: "process.stdout.columns"
      via: "terminal width detection"
      pattern: "process\\.stdout\\.columns"
    - from: "src/cli/banner.ts"
      to: "figlet fonts"
      via: "width-based font selection"
      pattern: "selectFont|font.*Small|font.*Mini"
---

<objective>
Add terminal width detection to ASCII banner so it gracefully degrades on narrow terminals.

Purpose: Ensure CLI branding works well on all terminal sizes - from wide desktop terminals to narrow mobile SSH clients (Termux), split panes, and piped output.

Output: Modified banner.ts with width detection and font fallback logic, comprehensive tests covering all width scenarios.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-ascii-banner-terminal-width/20-RESEARCH.md
@src/cli/banner.ts
@src/cli/__tests__/banner.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add width detection and font fallback to banner.ts</name>
  <files>src/cli/banner.ts</files>
  <action>
Modify generateBanner() to detect terminal width and select appropriate font:

1. Add helper function `getTerminalWidth()`:
   - Check `process.stdout.columns` first (primary source)
   - Fall back to `process.env.COLUMNS` if defined and valid
   - Default to 80 if both undefined
   - Return number

2. Add helper function `selectFont(width: number)`:
   - width >= 80: return 'Big' (current behavior, 63 chars)
   - width >= 60: return 'Small' (43 chars)
   - width >= 45: return 'Mini' (30 chars)
   - width < 45: return null (plain text fallback)

3. Add helper function `generatePlainBanner(version: string)`:
   - Return simple text array joined with newlines:
     - 'SCREENIE'
     - `v${version}`
     - 'Capture responsive screenshots across 57 device viewports'
     - 'Run: screenie --help'
     - empty line at end

4. Modify generateBanner():
   - Check if `process.stdout.isTTY` is false -> return generatePlainBanner
   - Get width via getTerminalWidth()
   - Get font via selectFont(width)
   - If font is null -> return generatePlainBanner
   - Use selected font in figlet.textSync() instead of hardcoded 'Big'
   - Keep picocolors styling for TTY output

Export only generateBanner (helpers are internal). Keep existing function signature.
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles.
Run `npm test -- src/cli/__tests__/banner.test.ts` to verify existing tests pass.
Manually test: `node -e "process.stdout.columns=40" && npx tsx src/cli/index.ts --version` should show plain text.
  </verify>
  <done>
generateBanner() detects terminal width and selects appropriate figlet font, falling back to plain text for narrow terminals or non-TTY contexts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for width-based font selection</name>
  <files>src/cli/__tests__/banner.test.ts</files>
  <action>
Add new test describe block for terminal width handling:

```typescript
describe('terminal width handling', () => {
  // Mock process.stdout for width testing
  // Note: These tests verify the font selection logic works correctly

  it('uses Big font for wide terminals (>=80 columns)', () => {
    // Big font creates distinctive wide patterns
    // Test that output contains the multi-underscore pattern from Big font
  });

  it('uses smaller font for narrow terminals (60-79 columns)', () => {
    // Test with mocked stdout.columns = 70
    // Verify output is still ASCII art but narrower
  });

  it('uses Mini font for very narrow terminals (45-59 columns)', () => {
    // Test with mocked stdout.columns = 50
    // Verify output is still ASCII art but very narrow
  });

  it('falls back to plain text for extremely narrow terminals (<45 columns)', () => {
    // Test with mocked stdout.columns = 40
    // Verify output is plain text without ASCII art patterns
    // Should contain 'SCREENIE' as literal text, not figlet
  });

  it('uses plain text for non-TTY output (pipes)', () => {
    // Test with mocked isTTY = false
    // Verify plain text output regardless of width
  });

  it('respects COLUMNS env var as fallback', () => {
    // Test with undefined stdout.columns but COLUMNS env set
  });

  it('defaults to 80 columns when no width info available', () => {
    // Test with both undefined
    // Should use Big font (default behavior)
  });
});
```

Use vitest's `vi.spyOn` or `vi.stubGlobal` to mock:
- `process.stdout.columns`
- `process.stdout.isTTY`
- `process.env.COLUMNS`

Ensure mocks are restored after each test with `afterEach`.

All tests should use `stripAnsi` for assertions on plain text content.
  </action>
  <verify>
Run `npm test -- src/cli/__tests__/banner.test.ts` - all tests pass including new ones.
Run `npm run lint` - no lint errors.
  </verify>
  <done>
Tests cover all width detection scenarios: wide (Big), medium (Small), narrow (Mini), very narrow (plain text), and non-TTY (plain text).
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. All tests pass: `npm test`
2. Build succeeds: `npm run build`
3. Manual verification of font fallback:
   - Normal terminal: `screenie --version` shows Big font banner
   - In narrow pane or with COLUMNS=50: shows Mini font
   - Piped output: `screenie --version | cat` shows plain text
</verification>

<success_criteria>
1. Banner detects terminal width at runtime using process.stdout.columns
2. Falls back to Small font at 60-79 columns, Mini at 45-59 columns
3. Falls back to plain text when terminal is <45 columns or non-TTY
4. All existing tests continue to pass
5. New tests cover all width scenarios
6. Build and lint pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-ascii-banner-terminal-width/20-01-SUMMARY.md`
</output>
