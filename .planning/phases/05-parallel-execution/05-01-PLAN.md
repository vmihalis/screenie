---
phase: 05-parallel-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/executor.ts
  - src/engine/types.ts
  - src/engine/index.ts
autonomous: true

must_haves:
  truths:
    - "Multiple devices capture simultaneously with configurable concurrency"
    - "Failed captures retry 2-3 times before failing permanently"
    - "Non-retryable errors (DNS, 404) do not retry"
    - "All results collected even with partial failures"
  artifacts:
    - path: "src/engine/executor.ts"
      provides: "Parallel execution with retry logic"
      min_lines: 100
      exports: ["captureAllDevices", "captureWithRetry", "isRetryableError"]
    - path: "src/engine/types.ts"
      provides: "Execution types"
      contains: "ExecutionOptions"
  key_links:
    - from: "src/engine/executor.ts"
      to: "src/engine/capturer.ts"
      via: "import captureScreenshot"
      pattern: "import.*captureScreenshot.*from.*capturer"
    - from: "src/engine/executor.ts"
      to: "p-limit"
      via: "import pLimit"
      pattern: "import pLimit from 'p-limit'"
---

<objective>
Implement parallel screenshot capture with concurrency control and automatic retry logic.

Purpose: Enables capturing 50+ device screenshots efficiently by running captures in parallel while respecting memory limits and retrying transient failures.

Output: `executor.ts` with `captureAllDevices` function that wraps `captureScreenshot` with p-limit concurrency and retry logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-parallel-execution/05-RESEARCH.md
@src/engine/capturer.ts
@src/engine/types.ts
@src/engine/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add execution types to types.ts</name>
  <files>src/engine/types.ts</files>
  <action>
Add the following types to the existing types.ts file (append after ScreenshotResult):

```typescript
/**
 * Options for parallel execution
 */
export interface ExecutionOptions {
  /** Max concurrent captures (default: 10) */
  concurrency?: number;
  /** Max retry attempts per device (default: 3) */
  maxRetries?: number;
  /** Delay between retries in ms (default: 500) */
  retryDelay?: number;
  /** Progress callback (completed, total, result) */
  onProgress?: (completed: number, total: number, result: ExecutionResult) => void;
}

/**
 * Extended result with retry information
 */
export interface ExecutionResult extends ScreenshotResult {
  /** Number of attempts made (1 = first attempt succeeded) */
  attempts: number;
}

/**
 * Aggregate results from parallel capture
 */
export interface CaptureAllResult {
  /** Individual results for each device */
  results: ExecutionResult[];
  /** Count of successful captures */
  successCount: number;
  /** Count of failed captures */
  failureCount: number;
  /** Total capture attempts (includes retries) */
  totalAttempts: number;
}
```

Why these types:
- ExecutionOptions mirrors Config.concurrency but adds retry config
- ExecutionResult extends ScreenshotResult with attempt tracking
- CaptureAllResult provides summary for CLI output (Phase 9 UX)
- onProgress callback prepares for Phase 9 progress indicators
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>ExecutionOptions, ExecutionResult, CaptureAllResult types defined in types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create executor.ts with retry and parallel capture</name>
  <files>src/engine/executor.ts</files>
  <action>
Create new file `src/engine/executor.ts` with:

1. **Imports:**
```typescript
import pLimit from 'p-limit';
import type { BrowserManager } from './browser.js';
import { captureScreenshot } from './capturer.js';
import type { Device } from '../devices/types.js';
import type { CaptureOptions, ExecutionOptions, ExecutionResult, CaptureAllResult } from './types.js';
```

2. **Non-retryable error patterns (const array):**
```typescript
const NON_RETRYABLE_PATTERNS = [
  'net::ERR_NAME_NOT_RESOLVED',  // DNS failure
  'net::ERR_CERT_',              // SSL/certificate errors
  'invalid url',                  // Malformed URL
  '404',                          // Page not found
  '403',                          // Forbidden
  '401',                          // Unauthorized
];
```

3. **isRetryableError function (export for testing):**
- Takes optional error string
- Returns false if error is undefined
- Checks if any NON_RETRYABLE_PATTERNS match (case-insensitive)
- Returns true if no patterns match (error is retryable)

4. **delay helper (internal):**
```typescript
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

5. **captureWithRetry function (export for testing):**
- Parameters: manager, options (CaptureOptions), maxRetries, retryDelay
- Returns Promise<ExecutionResult>
- Loop from attempt=1 to maxRetries
- Call captureScreenshot, if success return with attempts count
- If error is non-retryable OR last attempt, break loop
- Otherwise delay and continue
- Return last result with attempts count

6. **captureAllDevices function (main export):**
- Parameters: manager, url, devices[], captureOptions (Omit<CaptureOptions, 'url' | 'device'>), executionOptions
- Destructure executionOptions with defaults: concurrency=10, maxRetries=3, retryDelay=500
- Create p-limit limiter
- Map devices to tasks: limit(() => captureWithRetry(...))
- In task wrapper, call onProgress if provided after each capture
- Use Promise.allSettled to collect all results
- Process settled results into ExecutionResult[]
- Handle rejected promises (unexpected - wrap in error result)
- Calculate successCount, failureCount, totalAttempts
- Return CaptureAllResult

Pattern from research:
```typescript
const tasks = devices.map((device, index) =>
  limit(async () => {
    const result = await captureWithRetry(
      manager,
      { ...captureOptions, url, device },
      maxRetries,
      retryDelay
    );
    executionOptions.onProgress?.(index + 1, devices.length, result);
    return result;
  })
);
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>executor.ts exists with captureWithRetry and captureAllDevices functions</done>
</task>

<task type="auto">
  <name>Task 3: Export executor from engine index</name>
  <files>src/engine/index.ts</files>
  <action>
Add exports to src/engine/index.ts:

1. Add type exports:
```typescript
export type {
  ExecutionOptions,
  ExecutionResult,
  CaptureAllResult,
} from './types.js';
```

2. Add function exports:
```typescript
export { captureAllDevices, captureWithRetry, isRetryableError } from './executor.js';
```

Place type exports with other type exports, function exports with other function exports.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>ExecutionOptions, ExecutionResult, CaptureAllResult, captureAllDevices, captureWithRetry, isRetryableError exported from engine index</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Build succeeds: `npm run build`
3. Executor types are importable: `import { ExecutionOptions, CaptureAllResult } from './engine/index.js'`
4. Executor functions are importable: `import { captureAllDevices, isRetryableError } from './engine/index.js'`
</verification>

<success_criteria>
- executor.ts contains captureAllDevices, captureWithRetry, isRetryableError
- types.ts contains ExecutionOptions, ExecutionResult, CaptureAllResult
- engine/index.ts exports all new types and functions
- All exports compile without TypeScript errors
- SHOT-02 parallel execution infrastructure ready
- SHOT-04 retry logic infrastructure ready
</success_criteria>

<output>
After completion, create `.planning/phases/05-parallel-execution/05-01-SUMMARY.md`
</output>
