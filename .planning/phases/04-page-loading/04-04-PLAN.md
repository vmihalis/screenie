---
phase: 04-page-loading
plan: 04
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - src/engine/__tests__/scroll.test.ts
  - src/engine/__tests__/capturer.test.ts
autonomous: true

must_haves:
  truths:
    - "scrollForLazyContent has unit tests for normal operation"
    - "scrollForLazyContent has unit tests for max iterations limit"
    - "scrollForLazyContent has unit tests for early stop on height stabilization"
    - "captureScreenshot tests verify wait buffer and animation disabling"
  artifacts:
    - path: "src/engine/__tests__/scroll.test.ts"
      provides: "Unit tests for scroll helper"
      min_lines: 50
    - path: "src/engine/__tests__/capturer.test.ts"
      provides: "Updated tests for page loading features"
      contains: "scrollForLazy"
  key_links:
    - from: "src/engine/__tests__/scroll.test.ts"
      to: "src/engine/scroll.ts"
      via: "import scrollForLazyContent"
      pattern: "import.*scrollForLazyContent"
---

<objective>
Add unit tests for page loading enhancements

Purpose: Verify LOAD-02, LOAD-03, SHOT-03 implementations work correctly
Output: New scroll.test.ts and updated capturer.test.ts with page loading tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-page-loading/04-RESEARCH.md

# Prior plan summaries
@.planning/phases/04-page-loading/04-01-SUMMARY.md
@.planning/phases/04-page-loading/04-02-SUMMARY.md
@.planning/phases/04-page-loading/04-03-SUMMARY.md

# Relevant source files
@src/engine/__tests__/capturer.test.ts
@src/engine/scroll.ts
@src/engine/capturer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scroll.test.ts with unit tests</name>
  <files>src/engine/__tests__/scroll.test.ts</files>
  <action>
Create new test file src/engine/__tests__/scroll.test.ts:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { chromium, Browser, Page } from 'playwright';
import { scrollForLazyContent } from '../scroll.js';

describe('scrollForLazyContent', () => {
  let browser: Browser;
  let page: Page;

  beforeAll(async () => {
    browser = await chromium.launch({ headless: true });
  });

  afterAll(async () => {
    await browser.close();
  });

  // Helper to create fresh page for each test
  async function createPage(): Promise<Page> {
    const context = await browser.newContext({
      viewport: { width: 800, height: 600 },
    });
    return context.newPage();
  }

  describe('basic operation', () => {
    it('should scroll through page content', async () => {
      page = await createPage();

      // Create a page with scrollable content
      await page.setContent(`
        <html>
          <body style="margin: 0;">
            <div style="height: 3000px; background: linear-gradient(red, blue);">
              Content
            </div>
          </body>
        </html>
      `);

      // Scroll should complete without error
      await scrollForLazyContent(page, 10, 5000);

      // Should return to top after scrolling
      const scrollY = await page.evaluate(() => window.scrollY);
      expect(scrollY).toBe(0);

      await page.context().close();
    });

    it('should return to top after scrolling', async () => {
      page = await createPage();

      await page.setContent(`
        <html>
          <body style="margin: 0;">
            <div style="height: 2000px;">Content</div>
          </body>
        </html>
      `);

      await scrollForLazyContent(page, 5, 3000);

      const scrollY = await page.evaluate(() => window.scrollY);
      expect(scrollY).toBe(0);

      await page.context().close();
    });
  });

  describe('iteration limits', () => {
    it('should stop at max iterations', async () => {
      page = await createPage();

      // Static page - should complete quickly with 1-2 iterations
      await page.setContent(`
        <html>
          <body style="margin: 0;">
            <div style="height: 1500px;">Static content</div>
          </body>
        </html>
      `);

      const start = Date.now();
      await scrollForLazyContent(page, 3, 10000);
      const duration = Date.now() - start;

      // Should complete well under timeout since page is static
      expect(duration).toBeLessThan(5000);

      await page.context().close();
    });

    it('should respect timeout budget', async () => {
      page = await createPage();

      await page.setContent(`
        <html>
          <body style="margin: 0;">
            <div style="height: 5000px;">Tall content</div>
          </body>
        </html>
      `);

      const start = Date.now();
      await scrollForLazyContent(page, 100, 1000); // Short timeout
      const duration = Date.now() - start;

      // Should stop around timeout, with some tolerance for execution time
      expect(duration).toBeLessThan(2000);

      await page.context().close();
    });
  });

  describe('height stabilization', () => {
    it('should stop early if page height stabilizes', async () => {
      page = await createPage();

      // Static page - height won't change
      await page.setContent(`
        <html>
          <body style="margin: 0;">
            <div style="height: 1200px;">Static</div>
          </body>
        </html>
      `);

      const start = Date.now();
      await scrollForLazyContent(page, 10, 10000);
      const duration = Date.now() - start;

      // Should complete quickly since height doesn't change after first scroll
      expect(duration).toBeLessThan(3000);

      await page.context().close();
    });
  });

  describe('short pages', () => {
    it('should handle pages shorter than viewport', async () => {
      page = await createPage();

      await page.setContent(`
        <html>
          <body style="margin: 0;">
            <div style="height: 100px;">Short</div>
          </body>
        </html>
      `);

      // Should not error on short pages
      await scrollForLazyContent(page, 10, 5000);

      const scrollY = await page.evaluate(() => window.scrollY);
      expect(scrollY).toBe(0);

      await page.context().close();
    });
  });
});
```

Test coverage:
- Basic scrolling operation
- Returns to top after scroll
- Respects max iterations
- Respects timeout budget
- Stops early on height stabilization
- Handles short pages gracefully
  </action>
  <verify>
1. File exists: ls src/engine/__tests__/scroll.test.ts
2. Tests pass: npm test -- scroll.test.ts
  </verify>
  <done>
- scroll.test.ts exists with tests for scrollForLazyContent
- Tests cover basic operation, iteration limits, height stabilization
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add page loading tests to capturer.test.ts</name>
  <files>src/engine/__tests__/capturer.test.ts</files>
  <action>
Add new test section to src/engine/__tests__/capturer.test.ts for page loading features:

Add after the existing describe blocks:

```typescript
  describe('page loading features', () => {
    it('should capture with scrollForLazy enabled (default)', async () => {
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
        // scrollForLazy defaults to true
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(true);
      expect(result.buffer).toBeDefined();
    });

    it('should capture with scrollForLazy disabled', async () => {
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
        scrollForLazy: false,
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(true);
      expect(result.buffer).toBeDefined();
    });

    it('should respect custom maxScrollIterations', async () => {
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 500,
        scrollForLazy: true,
        maxScrollIterations: 2,
      };

      const result = await captureScreenshot(manager, options);

      expect(result.success).toBe(true);
      expect(result.buffer).toBeDefined();
    });

    it('should apply wait buffer', async () => {
      const options: CaptureOptions = {
        url: 'https://example.com',
        device: testPhone,
        timeout: DEFAULT_TIMEOUT,
        waitBuffer: 100, // Short buffer for faster test
        scrollForLazy: false, // Skip scroll to isolate buffer test
      };

      const start = Date.now();
      const result = await captureScreenshot(manager, options);
      const duration = Date.now() - start;

      expect(result.success).toBe(true);
      // Should take at least the buffer time (100ms) plus navigation
      expect(duration).toBeGreaterThan(100);
    });
  });
```

Also update CaptureOptions import if needed to include the new optional fields.
  </action>
  <verify>
1. npm test -- capturer.test.ts passes
2. grep "page loading features" src/engine/__tests__/capturer.test.ts shows section exists
  </verify>
  <done>
- capturer.test.ts has new "page loading features" describe block
- Tests verify scrollForLazy enabled/disabled behavior
- Tests verify custom maxScrollIterations
- Tests verify wait buffer is applied
- All tests pass
  </done>
</task>

</tasks>

<verification>
- `npm test` passes all tests
- New tests cover: scroll behavior, buffer timing, scroll options
- Total test count increased from Phase 3 baseline
</verification>

<success_criteria>
1. scroll.test.ts exists with comprehensive tests
2. capturer.test.ts has page loading feature tests
3. All tests pass
4. LOAD-02, LOAD-03, SHOT-03 implementations verified by tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-page-loading/04-04-SUMMARY.md`
</output>
