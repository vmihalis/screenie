---
phase: 04-page-loading
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/scroll.ts
  - src/engine/index.ts
autonomous: true

must_haves:
  truths:
    - "Page scrolls through content to trigger lazy-loaded images"
    - "Scrolling stops after max iterations to prevent infinite scroll hang"
    - "Scrolling stops early if page height stabilizes"
    - "Page returns to top after scrolling"
  artifacts:
    - path: "src/engine/scroll.ts"
      provides: "scrollForLazyContent helper function"
      exports: ["scrollForLazyContent"]
      min_lines: 40
    - path: "src/engine/index.ts"
      provides: "Re-export of scroll function"
      contains: "scrollForLazyContent"
  key_links:
    - from: "src/engine/scroll.ts"
      to: "page.evaluate"
      via: "window.scrollTo calls"
      pattern: "scrollTo.*0.*y"
    - from: "src/engine/scroll.ts"
      to: "page.waitForTimeout"
      via: "delays between scroll steps"
      pattern: "waitForTimeout.*100"
---

<objective>
Create scroll helper function to trigger lazy-loaded content

Purpose: Implement LOAD-03 (lazy content scroll) as a dedicated helper that can be integrated into captureScreenshot
Output: New src/engine/scroll.ts with scrollForLazyContent function
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-page-loading/04-RESEARCH.md

# Relevant source files
@src/engine/capturer.ts
@src/engine/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scrollForLazyContent helper function</name>
  <files>src/engine/scroll.ts</files>
  <action>
Create new file src/engine/scroll.ts with scrollForLazyContent function:

```typescript
import type { Page } from 'playwright';

/**
 * Scroll through page to trigger lazy-loaded content.
 *
 * Scrolls in viewport-sized increments, checking if page height grows
 * (indicating more content loaded). Stops when:
 * - Max iterations reached (prevents infinite scroll hang)
 * - Page height stabilizes (no new content)
 * - Timeout budget exhausted
 *
 * Returns to top of page after scrolling.
 *
 * @param page - Playwright page instance
 * @param maxIterations - Maximum scroll passes (default 10)
 * @param timeout - Time budget in ms (default 5000)
 */
export async function scrollForLazyContent(
  page: Page,
  maxIterations: number = 10,
  timeout: number = 5000
): Promise<void> {
  const startTime = Date.now();
  const viewportHeight = page.viewportSize()?.height ?? 800;
  let previousHeight = 0;
  let iterations = 0;

  while (iterations < maxIterations) {
    // Check timeout budget
    if (Date.now() - startTime > timeout) {
      break;
    }

    const currentHeight = await page.evaluate(() => document.body.scrollHeight);

    // Stop if page height stabilized (no new content loaded)
    if (currentHeight === previousHeight) {
      break;
    }

    previousHeight = currentHeight;

    // Scroll through current page content in viewport-sized steps
    const scrollStep = Math.floor(viewportHeight * 0.8); // 80% of viewport for overlap
    for (let pos = 0; pos < currentHeight && Date.now() - startTime < timeout; pos += scrollStep) {
      await page.evaluate((y) => window.scrollTo(0, y), pos);
      await page.waitForTimeout(100); // Brief pause for lazy loaders to trigger
    }

    // Brief wait for any triggered lazy loads to complete network requests
    try {
      await page.waitForLoadState('networkidle', { timeout: 2000 });
    } catch {
      // Network didn't idle in 2s, continue anyway
    }

    iterations++;
  }

  // Return to top for screenshot
  await page.evaluate(() => window.scrollTo(0, 0));
  await page.waitForTimeout(100); // Let page settle at top
}
```

Key implementation details:
- Uses 80% viewport overlap to ensure lazy images near edges are triggered
- 100ms delay per scroll step (fast but gives lazy loaders time to trigger)
- Short networkidle wait (2s) after each pass to catch triggered loads
- Timeout budget prevents hangs on slow pages
- Always returns to top for consistent screenshot starting point
  </action>
  <verify>
1. File exists: ls src/engine/scroll.ts
2. TypeScript compiles: npm run build
3. Function is exported: grep "export async function scrollForLazyContent" src/engine/scroll.ts
  </verify>
  <done>
- src/engine/scroll.ts exists with scrollForLazyContent function
- Function accepts page, maxIterations, timeout parameters
- Function scrolls in viewport increments with 100ms delays
- Function stops on max iterations OR height stabilization OR timeout
- Function returns to top after scrolling
- Build passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Export scroll function from engine index</name>
  <files>src/engine/index.ts</files>
  <action>
Add export for scrollForLazyContent in src/engine/index.ts:

```typescript
export { scrollForLazyContent } from './scroll.js';
```

Add it alongside existing exports from browser.js and capturer.js.
  </action>
  <verify>
1. grep "scrollForLazyContent" src/engine/index.ts
2. npm run build passes
  </verify>
  <done>
- src/engine/index.ts exports scrollForLazyContent
- Build passes
  </done>
</task>

</tasks>

<verification>
- `npm run build` compiles without errors
- `ls src/engine/scroll.ts` shows file exists
- `grep -q "scrollForLazyContent" src/engine/index.ts` returns match
</verification>

<success_criteria>
1. scrollForLazyContent function exists in src/engine/scroll.ts
2. Function exported from src/engine/index.ts
3. Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-page-loading/04-02-SUMMARY.md`
</output>
