---
phase: 09-ux-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/errors.ts
  - src/cli/actions.ts
  - src/cli/__tests__/errors.test.ts
autonomous: true

must_haves:
  truths:
    - "Failed captures show device name and user-friendly error message"
    - "DNS errors show 'Domain not found' with URL check hint"
    - "Timeout errors show 'Page took too long' message"
    - "Final summary shows success/failure counts"
    - "Failures are listed with actionable hints"
  artifacts:
    - path: "src/cli/errors.ts"
      provides: "Error formatting and summary display functions"
      exports: ["formatCaptureError", "displayFailureSummary", "FormattedError"]
      min_lines: 80
    - path: "src/cli/__tests__/errors.test.ts"
      provides: "Unit tests for error formatting"
      min_lines: 60
  key_links:
    - from: "src/cli/errors.ts"
      to: "picocolors"
      via: "import pc"
      pattern: "pc\\.(red|dim|bold)"
    - from: "src/cli/actions.ts"
      to: "src/cli/errors.js"
      via: "error display import"
      pattern: "displayFailureSummary|formatCaptureError"
---

<objective>
Implement user-friendly error messages and failure summary display for screenshot captures.

Purpose: Transform raw Playwright errors into actionable messages with device names and hints. Show clear summary at end with success/failure counts. Satisfies requirement UX-03.

Output: Error formatting utility and summary display integrated into CLI actions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ux-polish/09-RESEARCH.md

# Existing code to modify
@src/cli/actions.ts
@src/engine/executor.ts (for error patterns reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error formatting utility</name>
  <files>src/cli/errors.ts</files>
  <action>
Create error formatter that categorizes Playwright errors and provides user-friendly messages.

```typescript
// src/cli/errors.ts
import pc from 'picocolors';
import type { ExecutionResult } from '../engine/types.js';

/**
 * Error types for categorization
 */
export type ErrorType = 'dns' | 'ssl' | 'connection' | 'timeout' | 'http' | 'url' | 'unknown';

/**
 * Formatted error with user-friendly message and optional hint
 */
export interface FormattedError {
  type: ErrorType;
  message: string;
  hint?: string;
}

/**
 * Format a capture error into a user-friendly message with actionable hint.
 *
 * Categorizes common Playwright/network errors and provides clear explanations.
 *
 * @param error - Error message string from capture attempt
 * @returns FormattedError with type, message, and optional hint
 *
 * @example
 * formatCaptureError('net::ERR_NAME_NOT_RESOLVED')
 * // { type: 'dns', message: 'Domain not found', hint: 'Check that the URL is spelled correctly' }
 */
export function formatCaptureError(error: string): FormattedError {
  const lower = error.toLowerCase();

  // DNS errors
  if (lower.includes('err_name_not_resolved')) {
    return {
      type: 'dns',
      message: 'Domain not found',
      hint: 'Check that the URL is spelled correctly',
    };
  }

  // SSL certificate errors
  if (lower.includes('err_cert_')) {
    return {
      type: 'ssl',
      message: 'SSL certificate error',
      hint: 'The site may have an invalid or expired certificate',
    };
  }

  // Connection refused
  if (lower.includes('err_connection_refused')) {
    return {
      type: 'connection',
      message: 'Connection refused',
      hint: 'The server may be down or not accepting connections',
    };
  }

  // Connection timeout/reset
  if (lower.includes('err_connection_timed_out') || lower.includes('err_connection_reset')) {
    return {
      type: 'connection',
      message: 'Connection failed',
      hint: 'Network issue or server unresponsive',
    };
  }

  // Timeout errors
  if (lower.includes('timeout') || lower.includes('exceeded')) {
    return {
      type: 'timeout',
      message: 'Page load timed out',
      hint: 'Try increasing --wait or check if page has heavy resources',
    };
  }

  // HTTP 404
  if (lower.includes('404') || lower.includes('not found')) {
    return {
      type: 'http',
      message: 'Page not found (404)',
      hint: 'Check that the URL path is correct',
    };
  }

  // HTTP 403
  if (lower.includes('403') || lower.includes('forbidden')) {
    return {
      type: 'http',
      message: 'Access forbidden (403)',
      hint: 'The server is blocking access to this page',
    };
  }

  // HTTP 401
  if (lower.includes('401') || lower.includes('unauthorized')) {
    return {
      type: 'http',
      message: 'Authentication required (401)',
      hint: 'This page requires login credentials',
    };
  }

  // Invalid URL
  if (lower.includes('invalid url') || lower.includes('invalid protocol')) {
    return {
      type: 'url',
      message: 'Invalid URL',
      hint: 'URL must start with http:// or https://',
    };
  }

  // Unknown errors - truncate if too long
  return {
    type: 'unknown',
    message: error.length > 60 ? error.slice(0, 57) + '...' : error,
    hint: undefined,
  };
}

/**
 * Display a single failure with formatted error
 */
function displayFailure(deviceName: string, error: string): void {
  const formatted = formatCaptureError(error);
  const symbol = pc.red('x');
  const device = pc.bold(deviceName);

  console.log(`  ${symbol} ${device}: ${formatted.message}`);

  if (formatted.hint) {
    console.log(pc.dim(`    Hint: ${formatted.hint}`));
  }
}

/**
 * Display summary of capture failures with formatted errors.
 *
 * Shows each failed device with user-friendly error message and hint.
 * Only displays failures, not successes.
 *
 * @param results - Array of execution results
 *
 * @example
 * displayFailureSummary(results);
 * // Output:
 * // Failures:
 * //   x iPhone 14 Pro: Domain not found
 * //     Hint: Check that the URL is spelled correctly
 */
export function displayFailureSummary(results: ExecutionResult[]): void {
  const failures = results.filter(r => !r.success);

  if (failures.length === 0) {
    return;
  }

  console.log('');
  console.log(pc.bold('Failures:'));

  for (const failure of failures) {
    displayFailure(failure.deviceName, failure.error ?? 'Unknown error');
  }
}

/**
 * Display final capture summary with counts.
 *
 * @param successCount - Number of successful captures
 * @param failureCount - Number of failed captures
 */
export function displayCaptureSummary(successCount: number, failureCount: number): void {
  console.log('');

  if (failureCount === 0) {
    console.log(pc.green(`All ${successCount} captures completed successfully`));
    return;
  }

  console.log(pc.bold('Summary:'));
  console.log(`  ${pc.green('Succeeded:')} ${successCount}`);
  console.log(`  ${pc.red('Failed:')} ${failureCount}`);
}
```

Key points:
- Categorizes errors by type for consistent handling
- Provides actionable hints where possible
- Truncates unknown errors to prevent terminal flooding
- Uses picocolors for consistent styling with rest of CLI
  </action>
  <verify>
`npx tsc --noEmit` passes - errors module compiles without errors
  </verify>
  <done>
src/cli/errors.ts exports formatCaptureError, displayFailureSummary, displayCaptureSummary, and FormattedError type
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate error display into actions.ts</name>
  <files>src/cli/actions.ts</files>
  <action>
Update runCapture to use error formatting and display failure summary.

**1. Add imports at top:**

```typescript
import { displayFailureSummary, displayCaptureSummary } from './errors.js';
```

**2. After the spinner completes (after spinner.succeed/warn), add failure summary:**

Find the section after spinner.warn (around the save/report section) and add:

```typescript
      // Show final spinner state
      if (result.failureCount === 0) {
        spinner.succeed(result.successCount);
      } else {
        spinner.warn(result.successCount, result.failureCount);
        // Display detailed failures with user-friendly messages
        displayFailureSummary(result.results);
      }
```

**3. Remove the old summary line:**

Delete or replace:
```typescript
console.log(pc.dim(`  ${result.successCount} succeeded, ${result.failureCount} failed`));
```

This is now handled by the spinner and displayFailureSummary.

**4. Update the final success message:**

At the end of runCapture, after the pages loop, update the completion message:

```typescript
    const totalDuration = Date.now() - startTime;
    console.log(pc.green(`\nDone in ${Math.round(totalDuration / 1000)}s`));
```

This stays the same but now follows the new formatted output.

**5. Update handleError to use formatCaptureError for argument errors:**

The existing handleError can remain mostly unchanged, but ensure the pattern is consistent:

```typescript
export function handleError(error: unknown): never {
  if (error instanceof Error) {
    console.error(pc.red('\nError: ') + error.message);

    // Check for common error types and provide hints
    if (error.message.includes('Invalid URL') || error.message.includes('Invalid protocol')) {
      console.error(pc.dim('Hint: URL must start with http:// or https://'));
      process.exit(2); // Argument error
    }

    if (error.message.includes('Concurrency') || error.message.includes('Wait buffer')) {
      process.exit(2); // Argument error
    }

    // General error
    process.exit(1);
  }

  console.error(pc.red('\nUnknown error:'), error);
  process.exit(1);
}
```

This is mostly unchanged - the improvement is in capture failure messages.
  </action>
  <verify>
`npm run build` succeeds and the CLI still works
  </verify>
  <done>
actions.ts imports and calls displayFailureSummary when captures fail, showing device names with user-friendly error messages and hints
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error formatting tests</name>
  <files>src/cli/__tests__/errors.test.ts</files>
  <action>
Create comprehensive unit tests for error formatting.

```typescript
// src/cli/__tests__/errors.test.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { formatCaptureError, displayFailureSummary, displayCaptureSummary } from '../errors.js';
import type { ExecutionResult } from '../../engine/types.js';

describe('error formatting', () => {
  describe('formatCaptureError', () => {
    describe('DNS errors', () => {
      it('formats ERR_NAME_NOT_RESOLVED', () => {
        const result = formatCaptureError('net::ERR_NAME_NOT_RESOLVED');
        expect(result.type).toBe('dns');
        expect(result.message).toBe('Domain not found');
        expect(result.hint).toContain('URL');
      });

      it('handles case variations', () => {
        const result = formatCaptureError('NET::err_name_not_resolved');
        expect(result.type).toBe('dns');
      });
    });

    describe('SSL errors', () => {
      it('formats ERR_CERT_AUTHORITY_INVALID', () => {
        const result = formatCaptureError('net::ERR_CERT_AUTHORITY_INVALID');
        expect(result.type).toBe('ssl');
        expect(result.message).toContain('SSL');
        expect(result.hint).toContain('certificate');
      });

      it('formats ERR_CERT_DATE_INVALID', () => {
        const result = formatCaptureError('net::ERR_CERT_DATE_INVALID');
        expect(result.type).toBe('ssl');
      });
    });

    describe('connection errors', () => {
      it('formats ERR_CONNECTION_REFUSED', () => {
        const result = formatCaptureError('net::ERR_CONNECTION_REFUSED');
        expect(result.type).toBe('connection');
        expect(result.message).toBe('Connection refused');
        expect(result.hint).toContain('server');
      });

      it('formats ERR_CONNECTION_TIMED_OUT', () => {
        const result = formatCaptureError('net::ERR_CONNECTION_TIMED_OUT');
        expect(result.type).toBe('connection');
        expect(result.message).toBe('Connection failed');
      });

      it('formats ERR_CONNECTION_RESET', () => {
        const result = formatCaptureError('net::ERR_CONNECTION_RESET');
        expect(result.type).toBe('connection');
      });
    });

    describe('timeout errors', () => {
      it('formats timeout message', () => {
        const result = formatCaptureError('Timeout 30000ms exceeded');
        expect(result.type).toBe('timeout');
        expect(result.message).toContain('timed out');
        expect(result.hint).toContain('--wait');
      });

      it('handles "exceeded" keyword', () => {
        const result = formatCaptureError('Navigation exceeded timeout');
        expect(result.type).toBe('timeout');
      });
    });

    describe('HTTP errors', () => {
      it('formats 404 errors', () => {
        const result = formatCaptureError('Page returned 404');
        expect(result.type).toBe('http');
        expect(result.message).toContain('404');
        expect(result.hint).toContain('path');
      });

      it('formats 403 errors', () => {
        const result = formatCaptureError('Access forbidden 403');
        expect(result.type).toBe('http');
        expect(result.message).toContain('403');
      });

      it('formats 401 errors', () => {
        const result = formatCaptureError('Unauthorized 401');
        expect(result.type).toBe('http');
        expect(result.message).toContain('401');
        expect(result.hint).toContain('login');
      });

      it('handles "not found" text', () => {
        const result = formatCaptureError('Page not found');
        expect(result.type).toBe('http');
        expect(result.message).toContain('404');
      });
    });

    describe('URL errors', () => {
      it('formats invalid URL', () => {
        const result = formatCaptureError('Invalid URL provided');
        expect(result.type).toBe('url');
        expect(result.message).toBe('Invalid URL');
        expect(result.hint).toContain('http');
      });

      it('formats invalid protocol', () => {
        const result = formatCaptureError('Invalid protocol: ftp');
        expect(result.type).toBe('url');
      });
    });

    describe('unknown errors', () => {
      it('returns unknown type for unrecognized errors', () => {
        const result = formatCaptureError('Some random error');
        expect(result.type).toBe('unknown');
        expect(result.message).toBe('Some random error');
        expect(result.hint).toBeUndefined();
      });

      it('truncates long error messages', () => {
        const longError = 'A'.repeat(100);
        const result = formatCaptureError(longError);
        expect(result.message.length).toBeLessThanOrEqual(60);
        expect(result.message).toContain('...');
      });

      it('does not truncate short messages', () => {
        const shortError = 'Short error';
        const result = formatCaptureError(shortError);
        expect(result.message).toBe('Short error');
        expect(result.message).not.toContain('...');
      });
    });
  });

  describe('displayFailureSummary', () => {
    let consoleLogSpy: ReturnType<typeof vi.spyOn>;

    beforeEach(() => {
      consoleLogSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    });

    afterEach(() => {
      consoleLogSpy.mockRestore();
    });

    it('does nothing when no failures', () => {
      const results: ExecutionResult[] = [
        { success: true, deviceName: 'iPhone', attempts: 1, buffer: Buffer.from('') },
      ];

      displayFailureSummary(results);

      expect(consoleLogSpy).not.toHaveBeenCalled();
    });

    it('displays failures with device names', () => {
      const results: ExecutionResult[] = [
        { success: false, deviceName: 'iPhone 14 Pro', error: 'net::ERR_NAME_NOT_RESOLVED', attempts: 1 },
      ];

      displayFailureSummary(results);

      const output = consoleLogSpy.mock.calls.map(call => call[0]).join('\n');
      expect(output).toContain('Failures');
      expect(output).toContain('iPhone 14 Pro');
      expect(output).toContain('Domain not found');
    });

    it('displays hints for known error types', () => {
      const results: ExecutionResult[] = [
        { success: false, deviceName: 'Pixel', error: 'Timeout exceeded', attempts: 1 },
      ];

      displayFailureSummary(results);

      const output = consoleLogSpy.mock.calls.map(call => call[0]).join('\n');
      expect(output).toContain('Hint');
    });

    it('handles multiple failures', () => {
      const results: ExecutionResult[] = [
        { success: true, deviceName: 'Success Device', attempts: 1, buffer: Buffer.from('') },
        { success: false, deviceName: 'Fail Device 1', error: 'Error 1', attempts: 1 },
        { success: false, deviceName: 'Fail Device 2', error: 'Error 2', attempts: 1 },
      ];

      displayFailureSummary(results);

      const output = consoleLogSpy.mock.calls.map(call => call[0]).join('\n');
      expect(output).toContain('Fail Device 1');
      expect(output).toContain('Fail Device 2');
      expect(output).not.toContain('Success Device');
    });

    it('handles missing error message', () => {
      const results: ExecutionResult[] = [
        { success: false, deviceName: 'Device', attempts: 1 },
      ];

      displayFailureSummary(results);

      const output = consoleLogSpy.mock.calls.map(call => call[0]).join('\n');
      expect(output).toContain('Unknown error');
    });
  });

  describe('displayCaptureSummary', () => {
    let consoleLogSpy: ReturnType<typeof vi.spyOn>;

    beforeEach(() => {
      consoleLogSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    });

    afterEach(() => {
      consoleLogSpy.mockRestore();
    });

    it('shows success message when no failures', () => {
      displayCaptureSummary(10, 0);

      const output = consoleLogSpy.mock.calls.map(call => call[0]).join('\n');
      expect(output).toContain('10');
      expect(output).toContain('successfully');
    });

    it('shows summary with counts when failures exist', () => {
      displayCaptureSummary(8, 2);

      const output = consoleLogSpy.mock.calls.map(call => call[0]).join('\n');
      expect(output).toContain('Summary');
      expect(output).toContain('Succeeded');
      expect(output).toContain('8');
      expect(output).toContain('Failed');
      expect(output).toContain('2');
    });
  });
});
```

Tests cover:
- All error type categorizations (DNS, SSL, connection, timeout, HTTP, URL, unknown)
- Case insensitivity
- Message truncation
- Summary display with and without failures
- Hint display
  </action>
  <verify>
`npm test -- src/cli/__tests__/errors.test.ts` passes all tests
  </verify>
  <done>
src/cli/__tests__/errors.test.ts has 25+ tests covering formatCaptureError for all error types, displayFailureSummary, and displayCaptureSummary
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. `npm test -- src/cli/__tests__/errors.test.ts` passes
3. All existing CLI tests still pass: `npm test -- src/cli`
4. Error messages include device name, type-specific message, and hint
</verification>

<success_criteria>
- formatCaptureError categorizes DNS, SSL, connection, timeout, HTTP, and URL errors
- Each error type has user-friendly message and actionable hint
- displayFailureSummary shows failed devices with formatted errors
- displayCaptureSummary shows success/failure counts
- Unknown errors are truncated to prevent terminal flooding
- All error tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-ux-polish/09-03-SUMMARY.md`
</output>
